---
layout: post
title: "2020년 1월 14일 개발로그"
---

<a name="opencv"></a>
# OPENCV

## SMOOTHING IMAGES

In this tutorial you will learn how to apply diverse linear filters to smooth images using OpenCV functions such as:

- blur
- GaussianBlur
- medianBlur
- bilateralFilter

### THEORY

Smoothing, also called blurring, is a simple are frequently used image processing operation.
There are many reasons for smoothing. In this tutorial we will focus on smoothing in order to reduce noise (other uses will be seen in the following tutorial). To perform a smoothing operation we will apply a filter to our image. The most common type of filter are linear, in which an output pixel's value is determined as a weighted sum of input pixel values:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mtext>out</mtext>
   </msub>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mi>,</mi>
       <mi>j</mi>
      </mrow>
     </mrow>
     <mo fence="true" stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">=</mo>
    <mrow>
     <munderover>
      <mo stretchy="false">∑</mo>
      <mrow>
       <mi>x</mi>
       <mo stretchy="false">=</mo>
       <msub>
        <mi>x</mi>
        <mtext>min</mtext>
       </msub>
      </mrow>
      <msub>
       <mi>x</mi>
       <mtext>max</mtext>
      </msub>
     </munderover>
     <mrow>
      <munderover>
       <mo stretchy="false">∑</mo>
       <mrow>
        <mi>y</mi>
        <mo stretchy="false">=</mo>
        <msub>
         <mi>y</mi>
         <mtext>min</mtext>
        </msub>
       </mrow>
       <msub>
        <mi>y</mi>
        <mtext>max</mtext>
       </msub>
      </munderover>
      <mrow>
       <msub>
        <mi>f</mi>
        <mtext>in</mtext>
       </msub>
       <mrow>
        <mo fence="true" stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mrow>
           <mi>i</mi>
           <mo stretchy="false">+</mo>
           <mi>x</mi>
          </mrow>
          <mi>,</mi>
          <mrow>
           <mi>j</mi>
           <mo stretchy="false">+</mo>
           <mi>y</mi>
          </mrow>
         </mrow>
        </mrow>
        <mo fence="true" stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>f</mi>
        <mtext>filter</mtext>
       </msub>
       <mrow>
        <mo fence="true" stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mi>x</mi>
          <mi>,</mi>
          <mi>y</mi>
         </mrow>
        </mrow>
        <mo fence="true" stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
 </semantics>
</math>

The function <math><semantics><mrow><msub><mi>f</mi><mtext>filter</mtext></msub><mrow><mo fence="true" stretchy="false">(</mo><mrow><mrow><mi>x</mi><mi>,</mi><mi>y</mi></mrow></mrow><mo fence="true" stretchy="false">)</mo></mrow></mrow></semantics></math> is called the kernel, which is nothing more than the coefficients of the filter. It helps to visualize a filter as a window of coefficients sliding across the image. There are many kind of filters, here we will mention the most used:

__NORMALIZED BOX FILTER__

This filter is the simplest of all! Each output pixel is the mean of its kernel neighbors (all of them contribute with equal weights).

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mtext>noralized box filter</mtext>
    </msub>
    <mo stretchy="false">=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi mathvariant="italic">width</mi>
      <mo stretchy="false">×</mo>
      <mi mathvariant="italic">height</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mrow>
    <mo fence="true" stretchy="true">[</mo>
    <mrow>
     <mtable>
      <mtr>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mo stretchy="false">⋯</mo>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mo stretchy="false">⋯</mo>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mo stretchy="false">⋮</mo>
       </mtd>
       <mtd>
        <mo stretchy="false">⋮</mo>
       </mtd>
       <mtd>
        <mo stretchy="false">⋮</mo>
       </mtd>
       <mtd>
        <mo stretchy="false">⋱</mo>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
       <mtd>
        <mo stretchy="false">⋯</mo>
       </mtd>
       <mtd>
        <mn>1</mn>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
    <mo fence="true" stretchy="true">]</mo>
   </mrow>
  </mrow>
 </semantics>
</math>

__GAUSSIAN FILTER__

Probably the most useful filter (although not the fastest). Gaussian filtering is done by convolving each point in the input array with a Gaussian kernel and then summing them all to produce the output array. Just to make the picture clearer, remember how a one-dimensional gaussian kernel look like?

![image](/assets/images/Smoothing_Tutorial_theory_gaussian_0.jpg)

> TODO: DRAW GAUSSIAN GRAPH

Assuming that an image is one-dimension, you can notice that the pixel located in the middle would have the biggest weight. The weight of its neighbors decreases as the spatial distance between them and the center pixel increase.

Remember that a two-dimensional gaussian can be represented as:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mtext>gaussian</mtext>
   </msub>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>x</mi>
       <mi>,</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo fence="true" stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">=</mo>
    <mi>A</mi>
   </mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mfrac>
      <mrow>
       <mo stretchy="false">−</mo>
       <msup>
        <mrow>
         <mo fence="true" stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>x</mi>
           <mo stretchy="false">−</mo>
           <msub>
            <mi>μ</mi>
            <mi>x</mi>
           </msub>
          </mrow>
         </mrow>
         <mo fence="true" stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <msub>
         <mi>σ</mi>
         <mi>x</mi>
        </msub>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
     <mo stretchy="false">+</mo>
     <mfrac>
      <mrow>
       <mo stretchy="false">−</mo>
       <msup>
        <mrow>
         <mo fence="true" stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mi>x</mi>
           <mo stretchy="false">−</mo>
           <msub>
            <mi>μ</mi>
            <mi>y</mi>
           </msub>
          </mrow>
         </mrow>
         <mo fence="true" stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <msub>
         <mi>σ</mi>
         <mi>y</mi>
        </msub>
        <mn>2</mn>
       </msup>
      </mrow>
     </mfrac>
    </mrow>
   </msup>
  </mrow>
 </semantics>
</math>

where <math><semantics><mi>μ</mi></semantics></math> is the mean (the peak) and <math><semantics><msup><mi>σ</mi><mn>2</mn></msup></semantics></math> represents the variance (per each of the variables x and y).

__MEDIAN FILTER__

The median filter run through each element of the signal (in this case the image) and replace each pixel with the median of its neighboring pixels (located in a square neighborhood arourd the evaluated pixel).

__BILATERAL FILTER__

So far, we have explained some filters which main goal is to smooth an input image. However, sometimes the filters do not only dissolve the noise, but also smooth away the edges. To avoid this (at certain extent at least), we can use a bilateral filter. In an analogous way as the Gaussian filter, the bilateral filter also considers the neighboring pixels with weights assigned to each of them. These weights have two components, the first of which is the same weighting used by the Gaussian filter. The second component takes into account the difference in intensity between the neighboring pixels and the evaluated one. For a more detailed explanation you can check [this link](http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html).
